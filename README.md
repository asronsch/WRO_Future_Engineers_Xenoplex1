# WRO_Future_Engineers_Xenoplex1

## Motivation und Hintergrund:
Jetzt im 21. Jahrhundert, in der Zeit von Digitalisierung und Automatisierung sämtlicher Prozesse, rückt auch die Technik rund um autonomes Fahren immer mehr in den Vordergrund der Wissenschaft. Deshalb wollten wir dieses Sachgebiet nun auch bei der World Robotic Olympiad thematisieren. Auch dieses vereinfachte Abbild der Realität hat uns gezeigt, wie komplex solche für uns scheinbar einfachen Vorgänge in Wirklichkeit sind. Aber genau diese Schwierigkeit war für uns letztendlich der Anreiz diese Herausforderung zu bewältigen.

## Der Aufbau des Fahrzeugs: 
Als Basis des Fahrzeugs dient das Chassis eines autonom fahrenden Fahrzeugs von Fischertechnik. Ein Raspberry pi 4B fungiert dabei als "Gehirn" des Fahrzeugs und steuert alle Abläufe. Bei dem Regionalwettbewerb in Waldkirch hatten wir statt dessen einen Arduino Due verbaut. Als Antrieb für das Roboterfahrzeug benutzen wir einen Encodermotor Competition 9V schwarz von Fischertechnik (Artikel-Nr. 186175) mit 0,61 Nm und 330 RPM im Nennbetrieb. Dieser wird über eine H-Brücke l298n mit 9V versorgt wird. Diese H-Brücke versorgt mit Hilfe des integrierten Spannungswandlers den Controller und alle Sensoren mit der Betriebsspannung von 5 Volt. Zur Lenkung verwenden wir den HYX-S0009A Servomotor von Blanko. Dieser hat ein Metallgetriebe welches ihn deutlich langlebiger macht. Bei früheren Versionen des Fahrzeugs verwendeten wir einen SG 90 oder den Fischertechnik Servo (Artikel-Nr. 132292). Beide Motoren waren wegen des Plastikgetriebes meist schon nach kurzer Zeit defekt. Links und rechts besitzt das Fahrzeug je einen Ultraschallsensor HC-SR04. Zur Bilderkennung verwenden wir eine Fischertechnik Kamera (Artikeln-Nr. 152522) die über USB an den Raspberry pi angeschlossen ist. Außerdem ist ein dreizelliger 11,1-Volt-Akku mit 35Wh und einem Blockierstrom (BSI) von 10 Ampere verbaut. Um die bereits gefahrenen Runden zu zählen benutzen wir den Kompassensor CMPS 12 von Robot Electronics. Um die Verkabelung übersichtlicher zu machen haben wir eine Platine erstellt, die den Verkabelungsaufwand minimiert.

## Programme:
Für jede der beiden gestellten Aufgabe haben wir ein speziell für diese Aufgabe angepasstes Programm entwickelt. Bei der Regionalmeisterschaft in Waldkirch waren unsere Programme in C++ programmiert. Für die Deutsche Meisterschaft sind wir auf Python umgestiegen.
### Aufgabe 1:
Für Aufgabe 1 werden zu Beginn selbstgeschriebene Bibliotheken für Sensorabfragen und Motoren hinzugefügt. Wir entschieden uns dazu, diese zwei Unterprogramme (Motor und Servosteuerung, Sensorabfragen) zu machen, weil das Programm dadurch übersichtlicher wird. Außerdem werden Variablen erstellt, z.B. für die Entfernungsmessung mit einem Ultraschallsensor oder für das Auslesen der Werte des Kompasssensors. Im Hauptteil dieses Programms werden zunächst die beiden Starttaster für links und rechts abgefragt, damit das Fahrzeug auf Kommando gestartet werden kann. Beim Drücken der Starttasten links oder rechts wird festgelegt ob der Roboter entsprechend im oder gegen den Uhrzeigersinn fährt. Nach der Eingabe durch einen der Taster wird der Motor für das Fahren nach vorne gestartet und die Vorderräder mit Hilfe des Servos geradeaus gerichtet. Im Programm wird jetzt durchgehend der Ultraschall abgefragt, der für die entsprechende Richtung vorgesehen ist. Dieser ist für die Erkennung des Abstands zur inneren Wand vorgesehen. Fährt der Roboter näher als 20 Zentimeter an die innere Wand, lenkt der Servomotor nach außen, um den Roboter in einem möglichst konstanten Abstand zur inneren Wand zu halten. Ist der Abstand größer als 20 Zentimeter, so lenkt der Roboter auf die Wand zu um den Abstand zu verringern. Wenn der Abstand aufgrund einer Ecke nun größer als 1,5 Meter gemessen wird, so fährt der Roboter eine Kurve, bis er schließlich wieder eine Wand registriert. Mithilfe des Kompasses und den Ecken wird der Rundenzähler erhöht. Nach drei vollständig gefahrenen Runden beziehungsweise nach zwölf Kurven stoppt das Fahrzeug, idealerweise für die volle Punktzahl in dieser Disziplin.
### Aufgabe 2:
Zu Beginn ist dieses Programm ähnlich aufgebaut wie für die erste Aufgabe. Es werden wieder die selbstgeschriebenen Bibliotheken für die Sensoren und Aktoren implementiert und alle Variablen deklariert. Außerdem wird Tensorflow implementiert. Im Hauptteil des Programmes für Aufgabe 2 werden erneut die Taster für die Auswahl der Richtung abgefragt. Für die Erkennung der Objekte mit entsprechender Zuordnung der Farben sorgt die open Source KI Tensorflow von Google. Zur Erstellung des KI Modells haben wir 225 Bilder der Objekte gemacht und mit der Software Labelmg die Objekte auf den Bildern makiert. Die Software erstellt dann zu jedem Bild eine extra Datei, in der die von uns eingezeichnete Position gespeichert ist. Eine weitere speziell für Tensorflow entwickelte Software hat dann aus diesen Dateien ein KI-Modell erstellt. Erkennt die KI dann ein rotes Hindernis auf der Fahrbahn, so lenkt der Roboter mit dem Servomotor rechts um das Hindernis herum. Ein grünes Hindernis umfährt das Fahrzeug links. Ist das soeben umfahrene Hindernis aus dem Blickfeld der Kamera verschwunden, positioniert sich das Fahrzeug wieder mittig auf der Fahrbahn. Wie auch schon im Programm für die erste Aufgabe implementiert, erkennt das Fahrzeug alle Ecken mit den Ultraschallsensoren auf der entsprechenden Seite. Wie auch schon im ersten Programm fährt der Roboter bei einem Abstand von mehr als 1,5 Meter auf der entsprechenden Seite eine Kurve, mit dem Unterschied, dass dies erst nach einer kurzen Verzögerung stattfindet, damit das Fahrzeug auch in der Kurve möglichst mittig fährt. Auch in diesem Programm werden die Kurven mit Ultraschall und Kompasssensor gezählt und der Roboter bleibt im Idealfall nach drei ganzen Runden im Startfeld stehen.

